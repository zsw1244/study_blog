(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{476:function(t,s,e){"use strict";e.r(s);var o=e(22),r=Object(o.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"reactdom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reactdom"}},[t._v("#")]),t._v(" "),e("strong",[t._v("ReactDOM")])]),t._v(" "),e("p",[e("strong",[t._v("ReactDOM.render第一个参数渲染的内容，第二个参数挂载的对象")])]),t._v(" "),e("p",[e("strong",[t._v("react动态传参使用{}")])]),t._v(" "),e("p",[e("strong",[t._v("jsx特点: 多个标签最外层(根)只能有一个标签")])]),t._v(" "),e("p",[e("strong",[t._v("建议使用es6创建类")])]),t._v(" "),e("p",[e("strong",[t._v("jsx可以给变量赋值html标签")])]),t._v(" "),e("p",[e("strong",[t._v("单标签需要/结尾")])]),t._v(" "),e("p",[e("strong",[t._v("class为jsx的关键字class使用className替代")])]),t._v(" "),e("p",[e("strong",[t._v("style绑定使用{{}}使用小驼峰命名法")])]),t._v(" "),e("p",[e("strong",[t._v("推荐使用箭头函数不需要传this")])]),t._v(" "),e("p",[e("strong",[t._v("如果没有使用raect现在可以选择不引入不会报错")])]),t._v(" "),e("p",[e("strong",[t._v("函数式组件没有this对象只是返回标签直接渲染到页面，不能更新状态")])]),t._v(" "),e("p",[e("strong",[t._v("给类组件设置参数限制，验证类型需要使用库prop-types，对父组件进行类型的限制，isRequired为必传参数")])]),t._v(" "),e("p",[e("strong",[t._v("实现插槽可以使用双标签和单标签俩种，双标签可在标签内写内容他会传给子组件，存放在this.props.childer里面存放的是数组，单标签可以给传递的内容命名，存放在this.props中")])]),t._v(" "),e("p",[e("strong",[t._v("类组件的跨组件传值用法：跨组件传值可以使用{...}把数据传递给下一层，展开语法es6的语法，也可以使用提供的api，：Context实现必须用双标签,第一步创建Context对象，第二使用双标签把标签套在里面，不能使用函数式组件,第三步把ProfileHeader.contextType=UserContest其中ProfileHeader接受内容的组件UserContest为Context创建的对象,如果没有找到就会使用Context中的默认 数据")])]),t._v(" "),e("p",[e("strong",[t._v("函数式组件跨组件传值用：Context实现必须用双标签,第一步创建Context对象，第二使用双标签把标签套在里面，不能使用函数式组件,第三步使用的组件设置消费者标签<XXX.consumer>{value=>{}}<XXX.consumer/>内部使用{}，用函数传递，value就是传参内容")])]),t._v(" "),e("p",[e("strong",[t._v("跨组件传值可以进行多层嵌套，不建议使用")])]),t._v(" "),e("p",[e("strong",[t._v("setdate为异步更新,不能说是同步异步，在不同的情况下有不一样的，在组件生命周期或React合成事件中，setState是异步，在setTimeout或者原生dom事件中，setState是同步；")])]),t._v(" "),e("p",[e("strong",[t._v("PureComponent防止嵌套组件，被反复调用")])]),t._v(" "),e("p",[e("strong",[t._v("setState传递的数据是不可变的数据")])]),t._v(" "),e("p",[e("strong",[t._v("不能在函数组件上使用 ref 属性，因为他们没有实例；可以通过 React.forwardRef ，hooks 中使用ref")])]),t._v(" "),e("p",[e("strong",[t._v("受控和非受控组件使用的时候需要取消默认行为")])]),t._v(" "),e("p",[e("strong",[t._v("高阶组件就是接受值为组件返回值为组件，在页面显示外有一个类包裹,就是在对组件进行劫持，可以在使用组件前进行操作")])]),t._v(" "),e("p",[e("strong",[t._v("高阶组件定义一个函数接受一个组件参数，返回一个组件参数，在定义一个组件，在使用函数调用组件暴露函数")])]),t._v(" "),e("p",[e("strong",[t._v("通过函数使用ref可以使用高阶组件forwardRef，传入的为俩个参数props，ref，ref就是传过来的ref")])]),t._v(" "),e("p",[e("strong",[t._v("可以在标签内部使用双括号写内联样式")])]),t._v(" "),e("p",[e("strong",[t._v("给样式分模块，css文件名改为.module.css可以分模块化使用")])]),t._v(" "),e("p",[e("strong",[t._v("标签模板字符串: 可以通过模板字符串的方式对一个函数进行调用,可以通过插值的方式插入函数动态获取状态")])]),t._v(" "),e("p",[e("strong",[t._v("使用第三方库动态添加class,yarn add classnames")])]),t._v(" "),e("p",[e("strong",[t._v("不能通过es6方式导入，他是根据node判断的")])]),t._v(" "),e("p",[e("strong",[t._v("ChildCpn.propTypes={")]),t._v("**\n"),e("strong",[e("strong",[t._v("name:PropTypes.string.isRequired,")])]),t._v(" "),e("strong",[e("strong",[t._v("age:PropTypes.number,")])]),t._v(" "),e("strong",[e("strong",[t._v("height:PropTypes.number,")])]),t._v(" "),e("strong",[e("strong",[t._v("names:PropTypes.array")])]),t._v("\n**"),e("strong",[t._v("}")])]),t._v(" "),e("p",[e("strong",[t._v("redux在项目里的使用，第一步：引入封装好的文件")]),t._v(" "),e("code",[t._v("import store from '../store'")]),e("strong",[t._v("，在this.state中设置值，让他等于rudex中的，名字为引入store.getSate.xxx，xxx为你封装的rudex中的值，第二步：写函数调用")]),t._v(" "),e("code",[t._v("store.dispatch(addAction(1))")]),e("strong",[t._v("，在调用时候引入对应文件")]),t._v(" "),e("code",[t._v("import {addAction} from '../store/actionCreators'")]),t._v("** 第三步：在**"),e("code",[t._v("componentDidMount（）")]),e("strong",[t._v("写订阅并且重新加载this.state中的数据，还要接受订阅返回的值用来取消订阅，写this是为了在其他函数中调用")]),t._v(" "),e("code",[t._v("this.unsubscribe= store.subscribe(()=>{}")]),e("strong",[t._v("第四步：在")]),t._v(" "),e("code",[t._v("componentWillUnmount(){}")]),e("strong",[t._v("取消订阅，调用刚才订阅返回的函数即可")])]),t._v(" "),e("p",[e("strong",[t._v("hooks使用在react库中引入useState，定义变量const [count,setCount]=useState(0)，其中第一个参数是显示的值，第二个为调用这个值的函数，（）中的是定义值为多少，他是一个数组")])]),t._v(" "),e("p",[e("strong",[t._v("hooks添加数据需要先使用展开语法，后加添加的数组，他是实现拷贝操作然后把原来的覆盖")])]),t._v(" "),e("p",[e("strong",[t._v("由于hooks是使用校验前后参数是否相同进行重新渲染页面，使用push指针不发生改变不会重新渲染页面实际已经修改了数据，但是不会刷新页面")])]),t._v(" "),e("p",[e("strong",[t._v("hooks的useEffect其中俩个参数第二个可以不传，第二个参数是写依赖谁，谁跟新这个就跟着更新，是一个数组，空数组就是谁也不依赖，第二个参数主要是实现性能优化")])]),t._v(" "),e("p",[e("strong",[t._v("useReducer第一个参数传入一个纯函数，第二个是一个初始化值，可以 是一个值也可以是一个对象，具体操作会和他初始化的值有区别，如果是一个值者可以直接使用state，然后是对象这需要state.xxx，其中的xxx为他对象里面的名，他的数据不能像rudex一样共享数据，并没有共享state在接受返回值时会拿到自己的state，不能替代rudex")])]),t._v(" "),e("p",[e("strong",[t._v("memo函数高阶组件防止重新渲染适合用在性能优化")])]),t._v(" "),e("p",[e("strong",[t._v("hooks的api第二个参数一般都为渲染对象，那个数据发生改变才会重新渲染这个api，一般都为数组,如果写的为空数组只会在页面首次刷新才会渲染，其他时候不会，若是数组有值，只会在这个值发生改变才会渲染")])]),t._v(" "),e("p",[e("strong",[t._v("前端项目一般第一步需要css样式的重置，一般使用")]),t._v(" "),e("code",[t._v("normalize.css")]),e("strong",[t._v(",第二步配置别名，安装")]),t._v(" "),e("code",[t._v("@craco/craco")]),e("strong",[t._v("，创建craco.config.js，package.json里的启动项改成craco启动")])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('   <label for=""></label>替代\n   <label htmlfor=""></label>\n\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("h2",{attrs:{id:"生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" "),e("strong",[t._v("生命周期")])]),t._v(" "),e("p",[e("strong",[t._v("第一步执行构造方法constructor然后执行render方法开始把组件挂载到dom树上，挂载成功执行componentDidMount一般在这写网络请求也可以添加订阅消息需要在componentWillUnmount取消订阅，当发生更新了以后执行componentDidUpdate，需要更新数据可以使用")])]),t._v(" "),e("p",[e("strong",[t._v("new propos、setState、forceUpdate来更新数据")])])])}),[],!1,null,null,null);s.default=r.exports}}]);