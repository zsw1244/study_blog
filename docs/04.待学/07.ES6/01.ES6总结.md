---
title: ES6总结
date: 2021-06-02 15:26:16
permalink: /pages/7cf21f/
categories:
  - 待学
  - ES6
tags:
  -
---

# **声明变量**

**1、变量不能重复声明**

**2、块级作用域**

**3、不存在变量提升**

**4、不影响作用域链**

# **let和var和const**

**const声明常量，一定得赋值初值，一般常量使用大写，常量的值不能修改，const也是块级作用域，对于数组和对象的元素修改, 不算做对常量的修改, 不会报错**

**var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以** `{}`**限定不了var声明变量的访问范围。**

`let`**非常适合用于 **`for`**循环内部的块级作用域。JS中的for循环体比较特殊，每次执行都是一个全新的独立的块作用域，用let声明的变量传入到 for循环体的作用域后，不会发生改变，不受外界的影响。**

**用** `let`**声明的变量，不存在变量提升。而且要求必须 等** `let`**声明语句执行完之后，变量才能使用，不然会报** `Uncaught ReferenceError`**错误。**

**ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。****
****总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。**

**let不允许在相同作用域内，重复声明同一个变量。否则报错：**`Uncaught SyntaxError: Identifier 'XXX' has already been declared`

**ES6的let让js真正拥有了块级作用域，也是向这更安全更规范的路走，虽然加了很多约束，但是都是为了让我们更安全的使用和写代码。ES6的let让js真正拥有了块级作用域，也是向这更安全更规范的路走，虽然加了很多约束，但是都是为了让我们更安全的使用和写代码。**

# **解构赋值**

**允许按照一定模式从数组和对象中提取值，对变量进行赋值使用{}**

# **模板字符串**

**使用``，引入字符串的方式，内容可以 直接使用换行符，可以使用变量拼接使用**
